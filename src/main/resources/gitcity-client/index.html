<!DOCTYPE html>
<head>
    <meta charset="utf-8"/>
    <script src='vendor/three.js'></script>
    <script src='vendor/FirstPersonControls.js'></script>
</head>

<body style='margin: 0; background-color: #d8e7ff; overflow: hidden;'>
<script>
    // from @mrdoob http://www.mrdoob.com/lab/javascript/webgl/city/01/
    //noinspection JSUnusedAssignment
    var THREEx = THREEx || {};

    THREEx.ProceduralCity = function (mapItems) {
        // build the base geometry for each building
        var boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        // translate the geometry to place the pivot point at the bottom instead of the center
        boxGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
        // get rid of the bottom face - it is never seen
        boxGeometry.faces.splice(6, 2);
        boxGeometry.faceVertexUvs[0].splice(6, 2);
        // change UVs for the top face
        // - it is the roof so it wont use the same texture as the side of the building
        // - set the UVs to the single coordinate 0,0. so the roof will be the same color
        //   as a floor row.
        boxGeometry.faceVertexUvs[0][4][0].set(0, 0);
        boxGeometry.faceVertexUvs[0][4][1].set(0, 0);
        boxGeometry.faceVertexUvs[0][4][2].set(0, 0);
        boxGeometry.faceVertexUvs[0][5][0].set(0, 0);
        boxGeometry.faceVertexUvs[0][5][1].set(0, 0);
        boxGeometry.faceVertexUvs[0][5][2].set(0, 0);
        // buildMesh
        var buildingMesh = new THREE.Mesh(boxGeometry);

        // base colors for vertexColors. light is for vertices at the top, shadow is for the ones at the bottom
        var light = new THREE.Color(0xffffff);
        var shadow = new THREE.Color(0x303050);

        var cityGeometry = new THREE.Geometry();
        var itemCount = mapItems ? mapItems.length : 20000;
        for (var i = 0; i < itemCount; i++) {

            if (mapItems) {
                // we got predefined buildings? apply building position
                var building = mapItems[i];
                buildingMesh.position.x = (building.x);
                buildingMesh.position.z = (building.z);
                buildingMesh.scale.x = building.w;
                buildingMesh.scale.y = building.h; //(Math.random() * Math.random() * Math.random() * buildingMesh.scale.x) * 8 + 8;
                buildingMesh.scale.z = building.l;
            } else {
                // put random building position
                buildingMesh.position.x	= Math.floor( Math.random() * 200 - 100 ) * 10;
                buildingMesh.position.z	= Math.floor( Math.random() * 200 - 100 ) * 10;
                // put a random scale
                buildingMesh.scale.x    = Math.random() * Math.random() * Math.random() * Math.random() * 50 + 10;
                buildingMesh.scale.y    = (Math.random() * Math.random() * Math.random() * buildingMesh.scale.x) * 8 + 8;
                buildingMesh.scale.z	= buildingMesh.scale.x;
            }

            // put a random rotation
            buildingMesh.rotation.y = 0; //Math.random()*Math.PI*2;

            // establish the base color for the buildingMesh
            var value = 1 - Math.random() * Math.random();
            var baseColor = new THREE.Color().setRGB(value + Math.random() * 0.1, value, value + Math.random() * 0.1);
            // set topColor/bottom vertexColors as adjustement of baseColor
            var topColor = baseColor.clone().multiply(light);
            var bottomColor = baseColor.clone().multiply(shadow);
            // set .vertexColors for each face
            var geometry = buildingMesh.geometry;
            for (var j = 0, jl = geometry.faces.length; j < jl; j++) {
                if (j === 4 || j === 5) {
                    // set face.vertexColors on root face
                    geometry.faces[j].vertexColors = [baseColor, baseColor, baseColor];
                } else if (j % 2 === 0) {
                    // set face.vertexColors on sides faces
                    geometry.faces[j].vertexColors = [topColor, bottomColor, topColor];
                } else {
                    // set face.vertexColors on sides faces
                    geometry.faces[j].vertexColors = [bottomColor, bottomColor, topColor];
                }
            }
            // merge it with cityGeometry - very important for performance
            buildingMesh.updateMatrix();
            cityGeometry.merge( buildingMesh.geometry, buildingMesh.matrix);
        }

        // generate the texture
        var texture = new THREE.Texture(generateTextureCanvas());
        texture.anisotropy = renderer.getMaxAnisotropy();
        texture.needsUpdate = true;

        // build the mesh
        var material = new THREE.MeshLambertMaterial({
            map: texture,
            vertexColors: THREE.VertexColors
        });
        var mesh = new THREE.Mesh(cityGeometry, material);
        return mesh;

        function generateTextureCanvas() {
            // build a small canvas 32x64 and paint it in white
            var canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 64;
            var context = canvas.getContext('2d');
            // plain it in white
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, 32, 64);
            // draw the window rows - with a small noise to simulate light variations in each room
            for (var y = 2; y < 64; y += 2) {
                for (var x = 0; x < 32; x += 2) {
                    var value = Math.floor(Math.random() * 64);
                    context.fillStyle = 'rgb(' + [value, value, value].join(',') + ')';
                    context.fillRect(x, y, 2, 1);
                }
            }

            // build a bigger canvas and copy the small one in it
            // This is a trick to upscale the texture without filtering
            var canvas2 = document.createElement('canvas');
            canvas2.width = 512;
            canvas2.height = 1024;

            context	= canvas2.getContext( '2d' );
            // disable smoothing
            context.imageSmoothingEnabled = false;
            context.webkitImageSmoothingEnabled = false;
            context.mozImageSmoothingEnabled = false;
            // then draw the image
            context.drawImage(canvas, 0, 0, canvas2.width, canvas2.height);
            // return the just built canvas2
            return canvas2;
        }
    };

    var updateFcts = [];
    var scene = new THREE.Scene();
    //scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.0025 );

    var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////

    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 3000);
    camera.position.y = 100;
    camera.position.z = 0;
    camera.position.x = 0;

    //////////////////////////////////////////////////////////////////////////////////
    //		add an object and make it move					//
    //////////////////////////////////////////////////////////////////////////////////
    var light = new THREE.HemisphereLight(0xfffff0, 0x101020, 1.25);
    light.position.set(0.75, 1, 0.25);
    scene.add(light);

    var material = new THREE.MeshBasicMaterial({color: 0x101018});
    var planeGeometry = new THREE.PlaneGeometry(2000, 2000);
    var plane = new THREE.Mesh(planeGeometry, material);
    plane.rotation.x = -90 * Math.PI / 180;
    scene.add(plane);

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////

    var city = new THREEx.ProceduralCity();
    //scene.add(city);

    //////////////////////////////////////////////////////////////////////////////////
    //		Camera Controls							//
    //////////////////////////////////////////////////////////////////////////////////
    var controls = new THREE.FirstPersonControls(camera);
    controls.movementSpeed = 20;
    controls.lookSpeed = 0.05;
    controls.lookVertical = true;
    controls.lat = -30;
    controls.lon = 128;
    controls.update(0);
    updateFcts.push(function (delta, now) {
        controls.update(delta);
    });

    //////////////////////////////////////////////////////////////////////////////////
    //		render the scene						//
    //////////////////////////////////////////////////////////////////////////////////
    updateFcts.push(function () {
        renderer.render(scene, camera);
    });

    //////////////////////////////////////////////////////////////////////////////////
    //		loop runner							//
    //////////////////////////////////////////////////////////////////////////////////
    var lastTimeMsec = null;
    requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        updateFcts.forEach(function (updateFn) {
            updateFn(deltaMsec / 1000, nowMsec / 1000)
        })
    });

      var loader = new THREE.XHRLoader();
      loader.load('/items/latest',
            function ( xhrResponse ) {
                var cityData = JSON.parse( xhrResponse );
                //noinspection JSUnresolvedVariable
                var newCity = new THREEx.ProceduralCity(cityData.mapItems);
                scene.remove(city);
                scene.add(newCity);
                city = newCity;
            }
    );
</script>
</body>
