<!DOCTYPE html>
<head>
    <meta charset="utf-8"/>

    <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
     to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <script src='vendor/three.js'></script>
    <script src='vendor/VRControls.js'></script>
    <script src='vendor/VREffect.js'></script>
    <script src='vendor/webvr-polyfill.js'></script>
    <script src='vendor/webvr-manager.js'></script>
    <!--<script src='vendor/FirstPersonControls.js'></script>-->
    <script src='vendor/vrControls.js'></script>
</head>

<body style='margin: 0; background-color: #d8e7ff; overflow: hidden;'>
<script>

    var

    // from @mrdoob http://www.mrdoob.com/lab/javascript/webgl/city/01/
    //noinspection JSUnusedAssignment
    var THREEx = THREEx || {};

    THREEx.ProceduralCity = function (mapItems) {
        // build the base geometry for each building
        var boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        // translate the geometry to place the pivot point at the bottom instead of the center
        boxGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
        // get rid of the bottom face - it is never seen
        boxGeometry.faces.splice(6, 2);
        boxGeometry.faceVertexUvs[0].splice(6, 2);
        // change UVs for the top face
        // - it is the roof so it wont use the same texture as the side of the building
        // - set the UVs to the single coordinate 0,0. so the roof will be the same color
        //   as a floor row.
        boxGeometry.faceVertexUvs[0][4][0].set(0, 0);
        boxGeometry.faceVertexUvs[0][4][1].set(0, 0);
        boxGeometry.faceVertexUvs[0][4][2].set(0, 0);
        boxGeometry.faceVertexUvs[0][5][0].set(0, 0);
        boxGeometry.faceVertexUvs[0][5][1].set(0, 0);
        boxGeometry.faceVertexUvs[0][5][2].set(0, 0);
        // buildMesh
        var buildingMesh = new THREE.Mesh(boxGeometry);

        // base colors for vertexColors. light is for vertices at the top, shadow is for the ones at the bottom
        var light = new THREE.Color(0xffffff);
        var shadow = new THREE.Color(0x303050);

        var cityGeometry = new THREE.Geometry();
        var itemCount = mapItems ? mapItems.length : 20000;
        for (var i = 0; i < itemCount; i++) {

            if (mapItems) {
                // we got predefined buildings? apply building position
                var building = mapItems[i];
                buildingMesh.position.x = (building.x);
                buildingMesh.position.z = (building.z);
                buildingMesh.scale.x = building.w;
                buildingMesh.scale.y = building.h; //(Math.random() * Math.random() * Math.random() * buildingMesh.scale.x) * 8 + 8;
                buildingMesh.scale.z = building.l;
            } else {
                // put random building position
                buildingMesh.position.x	= Math.floor( Math.random() * 200 - 100 ) * 10;
                buildingMesh.position.z	= Math.floor( Math.random() * 200 - 100 ) * 10;
                // put a random scale
                buildingMesh.scale.x    = Math.random() * Math.random() * Math.random() * Math.random() * 50 + 10;
                buildingMesh.scale.y    = (Math.random() * Math.random() * Math.random() * buildingMesh.scale.x) * 8 + 8;
                buildingMesh.scale.z	= buildingMesh.scale.x;
            }

            // put a random rotation
            buildingMesh.rotation.y = 0; //Math.random()*Math.PI*2;

            // establish the base color for the buildingMesh
            var value = 1 - Math.random() * Math.random();
            var baseColor = new THREE.Color().setRGB(value + Math.random() * 0.1, value, value + Math.random() * 0.1);
            // set topColor/bottom vertexColors as adjustement of baseColor
            var topColor = baseColor.clone().multiply(light);
            var bottomColor = baseColor.clone().multiply(shadow);
            // set .vertexColors for each face
            var geometry = buildingMesh.geometry;
            for (var j = 0, jl = geometry.faces.length; j < jl; j++) {
                if (j === 4 || j === 5) {
                    // set face.vertexColors on root face
                    geometry.faces[j].vertexColors = [baseColor, baseColor, baseColor];
                } else if (j % 2 === 0) {
                    // set face.vertexColors on sides faces
                    geometry.faces[j].vertexColors = [topColor, bottomColor, topColor];
                } else {
                    // set face.vertexColors on sides faces
                    geometry.faces[j].vertexColors = [bottomColor, bottomColor, topColor];
                }
            }
            // merge it with cityGeometry - very important for performance
            buildingMesh.updateMatrix();
            cityGeometry.merge( buildingMesh.geometry, buildingMesh.matrix);
        }

        // generate the texture
        var texture = new THREE.Texture(generateTextureCanvas());
        texture.anisotropy = renderer.getMaxAnisotropy();
        texture.needsUpdate = true;

        // build the mesh
        var material = new THREE.MeshLambertMaterial({
            map: texture,
            vertexColors: THREE.VertexColors
        });
        var mesh = new THREE.Mesh(cityGeometry, material);
        return mesh;

        function generateTextureCanvas() {
            // build a small canvas 32x64 and paint it in white
            var canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 64;
            var context = canvas.getContext('2d');
            // plain it in white
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, 32, 64);
            // draw the window rows - with a small noise to simulate light variations in each room
            for (var y = 2; y < 64; y += 2) {
                for (var x = 0; x < 32; x += 2) {
                    var value = Math.floor(Math.random() * 64);
                    context.fillStyle = 'rgb(' + [value, value, value].join(',') + ')';
                    context.fillRect(x, y, 2, 1);
                }
            }

            // build a bigger canvas and copy the small one in it
            // This is a trick to upscale the texture without filtering
            var canvas2 = document.createElement('canvas');
            canvas2.width = 512;
            canvas2.height = 1024;

            context	= canvas2.getContext( '2d' );
            // disable smoothing
            context.imageSmoothingEnabled = false;
            context.webkitImageSmoothingEnabled = false;
            context.mozImageSmoothingEnabled = false;
            // then draw the image
            context.drawImage(canvas, 0, 0, canvas2.width, canvas2.height);
            // return the just built canvas2
            return canvas2;
        }
    };

    var updateFcts = [];
    var scene = new THREE.Scene();
    //scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.0025 );

    var renderer = new THREE.WebGLRenderer({antialias: false/*, alpha: true */});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////

    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 3000);
    camera.position.y = 100;
    camera.position.z = 0;
    camera.position.x = 0;

    // Apply VR headset positional data to camera.
    var controls = new THREE.VRControls(camera);
    controls.standing = true;
    controls.userHeight = 120;

    // Connect camera to VR Controls object to let it move by keyboard and BT controler
    vrc.init();
    vrc.object = camera;
    vrc.moveSpeed = 0.5

    // Apply VR stereo rendering to renderer.
    var effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);
    var manager = new WebVRManager(renderer, effect, { hideButton: false, isUndistorted: false });

    var onResize = function onResize(e) {
        effect.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    };

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);

    //////////////////////////////////////////////////////////////////////////////////
    //		add an object and make it move					//
    //////////////////////////////////////////////////////////////////////////////////
    var light = new THREE.HemisphereLight(0xfffff0, 0x101020, 1.25);
    light.position.set(0.75, 1, 0.25);
    scene.add(light);

    // Szene-Hintergrund-Texturen
    /*var path = "img/citadella/";
    var urls = [path + 'posx.jpg', path + 'negx.jpg',
        path + 'posy.jpg', path + 'negy.jpg',
        path + 'posz.jpg', path + 'negz.jpg' ];
    var reflectionCube = new THREE.CubeTextureLoader().load( urls );
    reflectionCube.format = THREE.RGBFormat;
    scene.background = reflectionCube;*/


    var material = new THREE.MeshBasicMaterial({color: 0x101018});
    var planeGeometry = new THREE.PlaneGeometry(1000, 1000);
    var plane = new THREE.Mesh(planeGeometry, material);
    plane.rotation.x = -90 * Math.PI / 180;
    scene.add(plane);

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////

    var city = new THREEx.ProceduralCity();
    //scene.add(city);

    //////////////////////////////////////////////////////////////////////////////////
    //		Camera Controls							//
    //////////////////////////////////////////////////////////////////////////////////
    /*var mouseControl = new THREE.FirstPersonControls(camera);
    mouseControl.movementSpeed = 20;
    mouseControl.lookSpeed = 0.05;
    mouseControl.lookVertical = true;
    mouseControl.lat = -30;
    mouseControl.lon = 128;
    mouseControl.update(0);
    updateFcts.push(function (delta, now) {
        mouseControl.update(delta);
    });*/

    //////////////////////////////////////////////////////////////////////////////////
    //		render the scene						//
    //////////////////////////////////////////////////////////////////////////////////
    updateFcts.push(function () {
        renderer.render(scene, camera);
    });

    //////////////////////////////////////////////////////////////////////////////////
    //		loop runner							//
    //////////////////////////////////////////////////////////////////////////////////
    /*var lastTimeMsec = null;
    requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        updateFcts.forEach(function (updateFn) {
            updateFn(deltaMsec / 1000, nowMsec / 1000)
        })
    });*/

    requestAnimationFrame(animate);	// Request animation frame loop function

    var loader = new THREE.XHRLoader();
      loader.load('/items/latest',
            function ( xhrResponse ) {
                var cityData = JSON.parse( xhrResponse );
                //noinspection JSUnresolvedVariable
                var newCity = new THREEx.ProceduralCity(cityData.mapItems);
                scene.remove(city);
                scene.add(newCity);
                city = newCity;
            }
    );

    // Request animation frame loop function
    // ===========================================================================
    var lastRender = 0;
    function animate(timestamp) {
        var delta  = Math.min(timestamp - lastRender, 500);
        lastRender = timestamp;

        // Store the camera position, so we can set it back after reading the VR headset's position
        // (Workaround to use the head tracking direction but separate movement.)
        var camPosX = camera.position.x;
        var camPosZ = camera.position.z;

        // Update VR headset position and apply to camera.
        controls.update();

        camera.position.x = camPosX;
        camera.position.z = camPosZ;

        // Move camera and reset control states
        vrc.update(delta);

        camera.updateProjectionMatrix();

        // Render the scene through the manager.
        manager.render(scene, camera, timestamp);

        requestAnimationFrame( animate );	// repeat the animation
    }

</script>
</body>
